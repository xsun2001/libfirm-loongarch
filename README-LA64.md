# Loongarch64 backend for libFirm

## Setup libFIRM & cparser

1. Install Python **(Note: use Python 3.9 or less)**, Perl, CMake, Ninja.
2. Clone cparser: `git clone http://pp.ipd.kit.edu/git/cparser.git`. Note: **Do not recursive clone**, as we will use our version of libfirm.
3. Clone libFIRM: `git clone https://github.com/xsun2001/libfirm-loongarch.git cparser/libfirm`
4. CMake build: `mkdir build && cd build && cmake .. -G Ninja && cmake --build .`
5. Now you can use `./build/cparser` as a compiler which is compatible with GCC.

## Setup cross-compile toolchain & qemu emulator

If the architecture you are using is not Loongarch64, you should build a cross compiler and a qemu emulator first.

1. Use crosstool-ng to build a cross compiler.
   1. Clone crosstool-ng: `https://github.com/crosstool-ng/crosstool-ng.git`. Note: You have to use the github HEAD version to get the Loongarch64 suppport.
   2. Follow this [document](https://crosstool-ng.github.io/docs/install/) to install crosstool-ng.
   3. Load Loongarch64 sample config: `ct-ng loongarch64-unknown-linux-gnu`
   4. Config toolchain(Mostly the install path/prefix) using: `ct-ng menuconfig`
   5. Build toolchain: `ct-ng build`
   6. Add the toolchain install path to PATH environment variable.
2. Build qemu emulator.
   1. Download the latest qemu source code from [here](https://www.qemu.org/).
   2. Configure qemu build: `./configure --target-list=loongarch64-linux-user --prefix=/path/to/qemu/install`
   3. Build: `make && make install`
   4. Add the qemu install path to PATH environment variable.
   5. Use `qemu-loongarch64 -L "/path/to/your/cross-compiler/loongarch64-unknown-linux-gnu/sysroot" a.out` to run the compiled Loongarch64 binary.

## Test

In `libfirm/test` directory, this is some C source code and a test script `run-cparser.sh`.

Use `./run-cparser.sh idx` will use cparser to compile `idx.c` and generate the following files to `idx/` directory:

1. `idx.s`: Assembly code generated by cparser & libFIRM.
2. `idx.o`: Compiled binary file generated by cparser.
3. `idx.asm.s`: Disassembled assembly code generated by `objdump`.
4. `*.vcg`: IR Graph dumped by libFIRM.
   1. You need yComp to view those files. Download from [here](http://pp.ipd.kit.edu/firm/download/yComp-1.3.19.zip).
   2. And you also need a Java Runtime Environment (version 5-8) to run yComp. Download from [here](https://adoptium.net/temurin/releases/?version=8&package=jre).

The test cases include:

1. `001.c`: The simplest `main` functin.
2. `002.c`-`006.c`: Arithmetic operations.
3. `008.c`-`012.c`: Load/Store/Global variables.
4. `013.c`-`015.c`: Function call and parameter passing.
5. `016.c`-`022.c`: Comparison and basic `if` statement.
6. `023.c`: Elvis operator.
7. `024.c`: Fibonacci sequence.
8. `025.c`: Quick sort.
9. `026.c`: Merge sort.
10. `027.c`: Binary search.
11. `028.c`: Dijkstra algorithm.
12. `029.c`: Matrix multiplication.
13. `030.c`-`032.c`: Link to standard library. `scanf` `printf` `malloc` `free`